Первой моей реакцией было, что задача легко решается за O(N^2).

Такую реализацию я даже не стал делать.

Потом, мне захотелось понять, можно ли решить за O(N)?

По мере решения, казалось что получается сделать за O(N) без памяти. Но последний тестовый случай всё сломал.

Теперь я не очень-то уверен, что задача легко решается за O(N^2), а не за O(N^3).

O(N^3) сделал.

Есть алгоритм O(N) с O(N) места. Сделал.

Есть решения с динамическим программированием. Сделал.

Простое решение с O(N^2). Просто из каждой точки ростить радиус наружу. Сделал.

Есть решения, еспользующие Longest Common Substring.


Почему решение с shared_ptr было медленнее:

1. Хз. Я получал совсем-совсем разные цифры. Нифига не 309 ms, как я видел. А в пределах 5-10.	
2. Видимо at медленнее чем operator[].

cmake ../5-longest-palindromic-substring/ -DCMAKE_CXX_FLAGS="-g -O3"
valgrind --tool=callgrind ./solution
callgrind_annotate callgrind.out.4851
kcachegrind callgrind.out.4851